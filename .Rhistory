library(sctransform)
# 示例数据（可替换为你自己的 count matrix）
pbmc <- SeuratData::LoadData("pbmc3k")
install.packages('SeuratData')
BiocManager::install('SeuratData')
create_package("D:/projects/others/邱弘宇/RCode/CVTest")
library(usethis)
create_package("D:/projects/others/邱弘宇/RCode/CVTest")
library(Seurat)
library(dplyr)
library(hdf5r)
# 第一步 输入下数据瞅瞅长啥样
data_dir <- "D:/projects/others/邱弘宇/pbmc_matrix.h5"
counts <- Read10X_h5(filename = data_dir)  #36601(基因) x 12012(细胞) 应该是吧
library(hdf5r)
counts <- Read10X_h5(filename = data_dir)  #36601(基因) x 12012(细胞) 应该是吧
library(Seurat)
library(Seurat)
remove.packages("spatstat.utils")
remove.packages("spatstat.utils")
install.packages("spatstat.utils")
install.packages("spatstat.utils")
packageVersion("spatstat.utils")
library(Seurat)
library(Seurat)
library(dplyr)
library(hdf5r)
# 第一步 输入下数据瞅瞅长啥样
data_dir <- "D:/projects/others/邱弘宇/pbmc_matrix.h5"
counts <- Read10X_h5(filename = data_dir)  #36601(基因) x 12012(细胞) 应该是吧
seurat_obj <- CreateSeuratObject(counts = counts, project = "CVTest", min.cells = 3, min.features = 200)
summary(seurat_obj@meta.data$nCount_RNA) #这个是每个细胞的表达量(UMI)的统计信息 那这玩意儿有啥用嘞 可以用来辅助过滤细胞 作为一个参考吧 比如这里的Max = 355625这明显远高于平均值 可能是杀了两个或更多细胞 那就去掉呗
summary(seurat_obj@meta.data$nFeature_RNA) #这个是每个细胞表达多少基因的统计信息UMI和Gene啥差别知道吧
#第二步 过滤一下老弱病残细胞
seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = "^MT-") # 线粒体多 细胞不靠谱
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) #可视化 凑图用的 咋调参数还不会 当年学这个的时候还不是张老师的学生 对美没追求的
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 10) #参数咋选 一半看上面的summary 一半看人品
X0 <- seurat_obj@meta.data$nCount_RNA
X0
dim(X0)
X0[1]
X0[1,1]
seurat_obj@meta.data
seurat_obj
seurat_obj@meta.data
seurat_obj@assays
seurat_obj@assays$RNA
seurat_obj@assays$RNA$`counts.Gene Expression`
# 第三步 Normalization
# 自定义方法进行一下normalization 注意不要取log1p
linear_norm <- function(x) {
total_counts <- Matrix::colSums(x)
scale_factors <- total_counts / 10000
norm_x <- t(t(x) / scale_factors)
return(norm_x)
}
seurat_obj <- NormalizeData(seurat_obj,
normalization.method = linear_norm,
verbose = FALSE)
norm_x <- t(x / scale_factors)
# 第三步 Normalization
# 自定义方法进行一下normalization 注意不要取log1p
linear_norm <- function(x) {
total_counts <- Matrix::colSums(x)
scale_factors <- total_counts / 10000
norm_x <- t( x / scale_factors)
return(norm_x)
}
seurat_obj <- NormalizeData(seurat_obj,
normalization.method = linear_norm,
verbose = FALSE)
# 第三步 Normalization
# 自定义方法进行一下normalization 注意不要取log1p
linear_norm <- function(x) {
total_counts <- Matrix::colSums(x)
scale_factors <- total_counts / 10000
norm_x <-  x / scale_factors
return(norm_x)
}
seurat_obj <- NormalizeData(seurat_obj,
normalization.method = linear_norm,
verbose = FALSE)
# 第三步 Normalization
# 自定义一个归一化函数进行一下normalization 注意不要取log1p
linear_norm <- function(x) {
total_counts <- Matrix::colSums(x)
size_factors <- total_counts / 10000
norm_x <- sweep(x, 2, size_factors, FUN = "/")
return(norm_x)
}
seurat_obj <- NormalizeData(seurat_obj,
normalization.method = linear_norm,
verbose = FALSE)
seurat_obj@assays$RNA@counts
data_dir <- "D:/projects/others/邱弘宇/pbmc_matrix.h5"
counts <- Read10X_h5(filename = data_dir)  #36601(基因) x 12012(细胞)
seurat_obj <- CreateSeuratObject(counts = counts, project = "CVTest", min.cells = 3, min.features = 200)
summary(seurat_obj@meta.data$nCount_RNA) #这个是每个细胞的表达量(UMI)的统计信息 那这玩意儿有啥用嘞 可以用来辅助过滤细胞 作为一个参考吧 比如这里的Max = 355625这明显远高于平均值 可能是杀了两个或更多细胞 那就去掉呗
summary(seurat_obj@meta.data$nFeature_RNA) #这个是每个细胞表达多少基因的统计信息UMI和Gene啥差别知道吧
#第二步 过滤一下老弱病残细胞
seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = "^MT-") # 线粒体多 细胞不靠谱
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) #可视化 凑图用的 咋调参数还不会 当年学这个的时候还不是张老师的学生 对美没追求的
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 10) #参数咋选 一半看上面的summary 一半看人品
seurat_obj@assays$RNA@counts
seurat_obj@assays$RNA@features
seurat_obj@assays$RNA@assay.orig
seurat_obj@assays$RNA
seurat_obj@assays$RNA$`counts.Gene Expression`
# 第三步 Normalization
### 注意不要取log1p
total_counts <- Matrix::colSums(X0)
X0 <- seurat_obj@assays$RNA$`counts.Gene Expression` #过滤完之后 27075(基因) x 1738(细胞)
# 第三步 Normalization
### 注意不要取log1p
total_counts <- Matrix::colSums(X0)
size_factors <- total_counts / 10000
norm_counts <- sweep(X0, 2, size_factors, FUN = "/")
norm_counts
X0
# 4. 写入 RNA@data slot（注意要用 log-normalized 数据的位置）
seurat_obj@assays$RNA@data <- norm_counts
X1 <- sweep(X0, 2, size_factors, FUN = "/")
X1
# 第四步 Normalization
library(scran)
BiocManager::install('scran')
# 第四步 Normalization
library(scran)
fit <- trendVar(norm_mat, method = "loess", log = FALSE)
fit <- trendVar(X1, method = "loess", log = FALSE)
fit <- fitTrendVar(X1, method = "loess", log = FALSE)
### scran包来算
library(scran)
fit <- fitTrendVar(X1, method = "loess", log = FALSE)
version(scran)
scran.version
gene_means <- rowMeans(X1)
gene_vars <- rowVars(as.matrix(X1))
fit <- fitTrendVar(means = gene_means, vars = gene_vars, method = "loess")
fit <- fitTrendVar(means = gene_means, vars = gene_vars)
dec <- decomposeVar(means = gene_means, vars = gene_vars, trend = fit)
dec <- modelGeneVar(means = gene_means, vars = gene_vars, trend = fit)
dec <- modelGeneVar(x = X1, trend = fit)
dec <- modelGeneVar(x = X1)
dec
rCV2 <- dec$bio
packageVersion(scran)
packageVersion("scran")
knitr::opts_knit$set(root.dir = "D:/projects/LineageCast/LineageCast/")
knitr::opts_chunk$set(warning = FALSE)
ggplot(entropy_slope_combined, aes(x = id, y = cell_type)) +
geom_point(aes(size = abs(slope), color = sign_label), shape = 16) +
scale_color_manual(values = c("pos" = "#F29537", "neg" = "#90C3DA", "zero" = "grey")) +
theme(axis.text.y = element_text(angle = 0, vjust = 1, hjust = 0, size = 6),
axis.text.x = element_text(color = "black", size = 6, family = 'Arial'),
strip.background = element_rect(fill = "#DCDDDD"))+
theme(plot.margin=unit(c(5.5, 0.2, 5.5, 0.2),'cm'))+
labs(x = NULL, y = NULL)+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
ggplot(entropy_slope_combined, aes(x = id, y = cell_type)) +
geom_point(aes(size = abs(slope), color = sign_label), shape = 16) +
scale_color_manual(values = c("pos" = "#F29537", "neg" = "#90C3DA", "zero" = "grey")) +
theme(axis.text.y = element_text(angle = 0, vjust = 1, hjust = 0, size = 6),
axis.text.x = element_text(color = "black", size = 6, family = 'Arial'),
strip.background = element_rect(fill = "#DCDDDD"))+
theme(plot.margin=unit(c(5.5, 0.2, 5.5, 0.2),'cm'))+
labs(x = NULL, y = NULL)+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
knitr::opts_knit$set(root.dir = "D:/projects/LineageCast/LineageCast/")
knitr::opts_chunk$set(warning = FALSE)
library(LineageCast)
library(PATH)
library(Seurat)
library(ggplot2)
library(phangorn)
library(ggtreeExtra)
library(ggtree)
library(TreeTools)
library(ape)
library(readxl)
library(devtools)
knitr::opts_knit$set(root.dir = "D:/projects/LineageCast/LineageCast/")
knitr::opts_chunk$set(warning = FALSE)
library(LineageCast)
library(PATH)
library(Seurat)
library(ggplot2)
library(phangorn)
library(ggtreeExtra)
library(ggtree)
library(TreeTools)
library(ape)
library(readxl)
library(devtools)
remove.packages('fastmap')
remove.packages('fastmap')
install.packages('fastmap')
install.packages("fastmap")
BiocManager::install('devtools')
knitr::opts_knit$set(root.dir = "D:/projects/LineageCast/LineageCast/")
knitr::opts_chunk$set(warning = FALSE)
library(LineageCast)
library(PATH)
library(Seurat)
library(ggplot2)
library(phangorn)
library(ggtreeExtra)
library(ggtree)
library(TreeTools)
library(ape)
library(readxl)
library(devtools)
library(tidytree)
library(DCLEAR)
knitr::opts_knit$set(root.dir = "D:/projects/LineageCast/LineageCast/")
knitr::opts_chunk$set(warning = FALSE)
library(LineageCast)
library(PATH)
library(Seurat)
library(ggplot2)
library(phangorn)
library(ggtreeExtra)
library(ggtree)
library(TreeTools)
library(ape)
library(readxl)
library(devtools)
library(tidytree)
library(DCLEAR)
# Load filtered mouse embryo scRNA-seq data
# Uncomment the following line if using the unfiltered data
load("data/mouse_embryo/mouse_embroy_filtered.RData")
# Extract count data from the Seurat object
counts <- GetAssayData(object = mouse_embroy_filtered, slot = "counts")
ngenes <- nrow(counts)
ncells <- ncol(counts)
# Load filtered lineage barcode data
load("data/mouse_embryo/barcode_filtered.RData")
N_char <- ncol(barcode_filtered)
# Standardize cell IDs for both counts and barcode data
colnames(counts) <- rownames(barcode_filtered) <- paste("cell", 1:ncells, sep = "_")
# Extract UMAP embeddings from the Seurat object
umap_res <- Embeddings(mouse_embroy_filtered, reduction = "umap")
umap_df <- data.frame(UMAP1 = umap_res[, 1], UMAP2 = umap_res[, 2])
# Create a UMAP plot colored by cell states
p <- ggplot(umap_df) +
geom_point(aes(x = UMAP1, y = UMAP2, color = mouse_embroy_filtered$cell_states)) +
scale_color_brewer(palette = "Set1") +
labs(color = "Cluster ID") +
xlab("UMAP 1") +
ylab("UMAP 2") +
theme(axis.text = element_text(size = 15),
axis.title = element_text(size = 20),
legend.title = element_text(size = 15),
legend.text = element_text(size = 15))
p
# Assign cell IDs to the UMAP results
rownames(umap_res) <- paste("cell", 1:nrow(barcode_filtered), sep = "_")
# Extract cell state labels from the Seurat object
labels_new <- as.character(mouse_embroy_filtered$cell_states)
# Define state lineage paths
state_lineages <- list()
state_lineages[[1]] <- c("Ectoderm", "Endoderm")
state_lineages[[2]] <- c("Ectoderm", "Mesoderm")
names(state_lineages) <- paste0("L", 1:length(state_lineages))
# Perform barcode imputation to address stochastic dropout
barcodes <- dropout_imputation_alter(as.matrix(barcode_filtered), N_char, ncells, ceiling(N_char * 0.8))
# Create a data frame of cell IDs and their corresponding cell state labels
state <- data.frame(cell_id = paste("cell", 1:ncells, sep = "_"),
cluster = labels_new)
# Generate state lineage information
sl_info <- state_lineage_info(state_lineages, ncells, state, barcodes)
state_lineage <- sl_info[[1]]
cell_lineages <- sl_info[[2]]
barcodes_lineages <- sl_info[[3]]
state_labels_lineages <- sl_info[[4]]
# Construct initial sub-cell division trees based on state lineages and barcode data
Trees_initial <- initial_tree_construction(state_lineages, barcodes_lineages)
# Refine the initial subtrees using a maximum likelihood framework and subtree exchanges
refined_subtree <- subtree_refinement(Trees_initial, state_lineages, barcodes_lineages,N_char, state_labels_lineages,lambda1 = 0.1, lambda2 = 0.9,maxIter = 100, repeat_time = 10)
bestsubtree <- refined_subtree[[1]]
bestsubtree <- drop_duplicated_tips(bestsubtree, barcodes_lineages, cell_lineages,state_lineage, alpha = 1.5, beta = 1.5)
# Generate root barcodes for each subtree from the refined best sub-cell division trees
subtrees_rootbar <- get_subtree_root_barcodes(bestsubtree, state, barcodes, length(state_lineages))
# Compute the common mutation matrix between the subtrees' root barcodes
CM <- common_mutation_matrix(subtrees_rootbar)
# Compute ranking and weight matrices based on mutation patterns
Nodes_rank <- subtrees_rank(CM)[[1]]
Nodes_weight <- subtrees_rank(CM)[[2]]
# Decompose refined subtrees into sub-subtrees for further merging
subsubtrees <- decompose_subtrees(bestsubtree, state, barcodes, length(state_lineages))
# Merge the sub-cell division trees using Ward's method
Tree_Merge <- merge_subcell_trees_ward(subtrees_rootbar, subsubtrees)
# Combine root barcodes from subtrees into a single matrix
barcodes_lineage <- do.call(rbind, subtrees_rootbar)
rownames(barcodes_lineage) <- names(subtrees_rootbar)
# Compute a Hamming distance matrix between lineage barcodes
D <- hamming_distance(barcodes_lineage)
# Cluster nodes based on the Hamming distance to generate a backbone tree
tree_backbone <- nodes_clustering(D)
# Select a node from the backbone tree for further analysis
#node_name <- "3_2_node_6415"
node_name <- sample(tree_backbone$tip.label, 1)
# Find the position of the selected node in the backbone tree
a_positions <- sapply(node_name, function(node) which(tree_backbone$tip.label == node))
# Plot the backbone tree with tip labels; highlight the selected node
plot(tree_backbone, show.tip.label = FALSE, cex = 0.6)
# Extract a subtree corresponding to the selected node
subtree <- subsubtrees[[node_name]]
barcodes_subtree <- barcodes[match(subtree$tip.label, rownames(barcodes)), ]
# phylogenetic_subtree <- phylogenetic_tree(subtree, N_char, barcodes_subtree, ncells = NULL, Nnodes = NULL, edges = NULL)
# # Use the merged tree from previous steps for downstream analysis
tree <- Tree_Merge
# Map cell state labels to the tree tips
tree$states_chr <- labels_new[match(tree$tip.label, state$cell_id)]
tree$states <- as.numeric(factor(labels_new[match(tree$tip.label, state$cell_id)]))
tree$states[is.na(tree$states)] <- max(tree$states, na.rm = TRUE)
# Compute phylogenetic distances and auto-correlation metrics
W <- one_node_tree_dist(tree)
X <- catMat(tree$states)
treexcor <- xcor(X, W)
tree_phy_cor <- treexcor$phy_cor
Idf <- reshape2::melt(tree_phy_cor, value.name = "I")
Zdf <- reshape2::melt(treexcor$Z.score, value.name = "Z")
df <- full_join(Idf, Zdf, by = c("Var1", "Var2"))
df <- df %>% mutate(Var1 = as.factor(Var1), Var2 = as.factor(Var2))
# Phylogenetic auto-correlation (heritability) bar plots
herit1 <- df %>%
filter(Var1 == Var2) %>%
ggplot(aes(x = Var1, y = I, fill = Var1)) +
geom_bar(stat = "identity") +
ylim(c(-0.1, 1)) +
theme_classic() +
labs(fill = "Cell state", y = "Phylogenetic auto-correlation", x = "Cell state") +
ggtitle("Cell state heritability", subtitle = "auto-correlation")
maxz <- max(abs(df$Z))
herit2 <- df %>%
filter(Var1 == Var2) %>%
ggplot(aes(x = Var1, y = Z, fill = Var1)) +
geom_bar(stat = "identity") +
ylim(c(-maxz, maxz)) +
theme_classic() +
labs(fill = "Cell state", y = "Phylogenetic auto-correlation\n(z score)", x = "Cell state") +
geom_hline(yintercept = qnorm(0.05, lower.tail = FALSE), col = "black", lty = 2) +
ggtitle("Cell state heritability", subtitle = "z score")
# Display the heritability plots side by side
herit1 + herit2
# Plot a heatmap of the phylogenetic correlation between cell states
df %>%
ggplot(aes(x = Var1, y = Var2, fill = I)) +
geom_tile(col = "white") +
scale_fill_distiller(palette = 5, type = "div", limits = c(-1, 1)) +
theme_classic() +
scale_y_discrete(limits = rev) +
labs(fill = "Phylogenetic\ncorrelation", x = "Cell state", y = "Cell state") +
theme(aspect.ratio = 1)
leaf_states <- state$cluster
names(leaf_states) <- state$cell_id
depth_df <- compute_node_depths(Tree_Merge)
states <- unique(leaf_states)
entropy_path_list <- lapply(states, function(cell_type) {
df <- compute_entropy_path_alter(Tree_Merge, leaf_states, cell_type)
df$cell_type <- cell_type
return(df)
})
entropy_path_combined <- do.call(rbind, entropy_path_list)
theme_set(theme_light())
ggplot(entropy_path_combined, aes(x = depth, y = entropy ))+
geom_point(color = "#C692C0", alpha = 0.1)+
stat_smooth(method = 'gam' ,  color = "#7C4296", size = 0.7) +
#geom_line(color = "#7C4296", size = 0.7)+
theme(axis.text.x = element_text(angle =45, vjust =1, hjust =1))+
labs(x ="Depth", y ="Entropy")+
facet_wrap(~ cell_type, nrow = 1, ncol = 3)+
theme(axis.text = element_text(color = "black", size = 5.5, family = 'Arial'),
axis.title = element_text(family = 'Arial', size = 6),
strip.background = element_rect(fill = "#DCDDDD"),
strip.text = element_text(family = "Arial", face = "bold", color = "black",
hjust = 0, size = 6))+
theme(plot.margin=unit(c(4.7, 0.8, 4.7, 0.8),'cm'))+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
entropy_path_list <- lapply(states, function(cell_type) {
entropy_df <- entropy_path_combined[entropy_path_combined$cell_type == cell_type,]
valid <- !is.na(entropy_df$entropy)
H <- entropy_df$entropy[valid]
idx <- seq(1,length(H),20)
H_slope <- H[idx + 20] - H[idx]
slope_df <- data.frame(id = 1:length(H_slope), slope = H_slope, cell_type = cell_type, sign_label = sign(H_slope))
slope_df$sign_label <- factor(sign(slope_df$slope), levels = c(-1, 0, 1),
labels = c("neg", "zero", "pos"))
slope_df <- slope_df[c(1:40),]
slope_df$id <- slope_df$id*20
return(slope_df)
})
entropy_slope_combined <- do.call(rbind, entropy_path_list)
entropy_slope_combined <- entropy_slope_combined[!is.na(entropy_slope_combined['cell_type']),]
entropy_slope_combined <- entropy_slope_combined[!is.na(entropy_slope_combined['slope']),]
ggplot(entropy_slope_combined, aes(x = id, y = cell_type)) +
geom_point(aes(size = abs(slope), color = sign_label), shape = 16) +
scale_color_manual(values = c("pos" = "#F29537", "neg" = "#90C3DA", "zero" = "grey")) +
theme(axis.text.y = element_text(angle = 0, vjust = 1, hjust = 0, size = 6),
axis.text.x = element_text(color = "black", size = 6, family = 'Arial'),
strip.background = element_rect(fill = "#DCDDDD"))+
theme(plot.margin=unit(c(5.5, 0.2, 5.5, 0.2),'cm'))+
labs(x = NULL, y = NULL)+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
theme_set(theme_light())
ggplot(entropy_path_combined, aes(x = depth, y = entropy ))+
geom_point(color = "#C692C0", alpha = 0.1)+
stat_smooth(method = 'gam' ,  color = "#7C4296", size = 0.7) +
#geom_line(color = "#7C4296", size = 0.7)+
theme(axis.text.x = element_text(angle =45, vjust =1, hjust =1))+
labs(x ="Depth", y ="Entropy")+
facet_wrap(~ cell_type, nrow = 1, ncol = 3)+
theme(axis.text = element_text(color = "black", size = 5.5, family = 'Arial'),
axis.title = element_text(family = 'Arial', size = 6),
strip.background = element_rect(fill = "#DCDDDD"),
strip.text = element_text(family = "Arial", face = "bold", color = "black",
hjust = 0, size = 6))+
theme(plot.margin=unit(c(4.7, 0.8, 4.7, 0.8),'cm'))+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
theme_set(theme_light())
ggplot(entropy_path_combined, aes(x = depth, y = entropy ))+
geom_point(color = "#C692C0", alpha = 0.1)+
stat_smooth(method = 'gam' ,  color = "#7C4296", size = 0.7) +
#geom_line(color = "#7C4296", size = 0.7)+
theme(axis.text.x = element_text(angle =0, vjust =1, hjust =1))+
labs(x ="Depth", y ="Entropy")+
facet_wrap(~ cell_type, nrow = 1, ncol = 3)+
theme(axis.text = element_text(color = "black", size = 5.5, family = 'Arial'),
axis.title = element_text(family = 'Arial', size = 6),
strip.background = element_rect(fill = "#DCDDDD"),
strip.text = element_text(family = "Arial", face = "bold", color = "black",
hjust = 0, size = 6))+
theme(plot.margin=unit(c(4.7, 0.8, 4.7, 0.8),'cm'))+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
theme_set(theme_light())
ggplot(entropy_path_combined, aes(x = depth, y = entropy ))+
geom_point(color = "#C692C0", alpha = 0.1)+
stat_smooth(method = 'gam' ,  color = "#7C4296", size = 0.7) +
#geom_line(color = "#7C4296", size = 0.7)+
theme(axis.text.x = element_text(angle =0, vjust =1, hjust =1))+
labs(x ="Depth", y ="Entropy")+
facet_wrap(~ cell_type, nrow = 1, ncol = 3)+
theme(axis.text = element_text(color = "black", size = 5.5, family = 'Arial'),
axis.title = element_text(family = 'Arial', size = 6),
strip.background = element_rect(fill = "#DCDDDD"),
strip.text = element_text(family = "Arial", face = "bold", color = "black",
hjust = 0, size = 6))+
theme(plot.margin=unit(c(4.7, 0.8, 4.7, 0.8),'cm'))+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
rCV2
write.csv(rCV2,'D:/')
write.csv(rCV2,'D:/projects')
write.csv(rCV2,'D:/projects')
write.csv(rCV2,'D:/projects/rcv2.csv')
ggplot(entropy_slope_combined, aes(x = id, y = cell_type)) +
geom_point(aes(size = abs(slope), color = sign_label), shape = 16) +
scale_color_manual(values = c("pos" = "#F29537", "neg" = "#90C3DA", "zero" = "grey")) +
theme(axis.text.y = element_text(angle = 0, vjust = 1, hjust = 0, size = 6),
axis.text.x = element_text(color = "black", size = 6, family = 'Arial'),
strip.background = element_rect(fill = "#DCDDDD"))+
theme(plot.margin=unit(c(5.5, 0.2, 5.5, 0.2),'cm'))+
labs(x = NULL, y = NULL)+
theme(panel.grid.major = element_line(color = "#DCDDDD", size = 0.25),
panel.grid.minor = element_line(color = "#EFEFEF", size = 0.1))
package_version('scran')
library(scran)
package_version('scran')
version('scran')
# 执行 SCTransform 归一化（这一步包含变异性建模）
pbmc <- SCTransform(pbmc, verbose = FALSE)
# 加载必要包
library(Seurat)
library(sctransform)
# 示例数据（可替换为你自己的 count matrix）
pbmc <- SeuratData::LoadData("pbmc3k")
library(SeuratData)
BiocManager::install('SeuratData')
library(Seurat)
library(dplyr)
library(hdf5r)
# 第一步 输入下数据瞅瞅长啥样
data_dir <- "D:/projects/others/邱弘宇/pbmc_matrix.h5"
counts <- Read10X_h5(filename = data_dir)  #36601(基因) x 12012(细胞)
mean(counts)
counts <- Read10X_h5(filename = data_dir)  #36601(基因) x 12012(细胞)
seurat_obj <- CreateSeuratObject(counts = counts, project = "CVTest", min.cells = 3, min.features = 200)
summary(seurat_obj@meta.data$nCount_RNA) #这个是每个细胞的表达量(UMI)的统计信息 那这玩意儿有啥用嘞 可以用来辅助过滤细胞 作为一个参考吧 比如这里的Max = 355625这明显远高于平均值 可能是杀了两个或更多细胞 那就去掉呗
summary(seurat_obj@meta.data$nFeature_RNA) #这个是每个细胞表达多少基因的统计信息UMI和Gene啥差别知道吧
#第二步 过滤一下老弱病残细胞
seurat_obj[["percent.mt"]] <- PercentageFeatureSet(seurat_obj, pattern = "^MT-") # 线粒体多 细胞不靠谱
VlnPlot(seurat_obj, features = c("nFeature_RNA", "nCount_RNA", "percent.mt"), ncol = 3) #可视化 凑图用的 咋调参数还不会 当年学这个的时候还不是张老师的学生 对美没追求的
seurat_obj <- subset(seurat_obj, subset = nFeature_RNA > 200 & nFeature_RNA < 5000 & percent.mt < 10) #参数咋选 一半看上面的summary 一半看人品
X0 <- seurat_obj@assays$RNA$`counts.Gene Expression` #过滤完之后 27075(基因) x 1738(细胞)
# 第三步 Normalization
### 注意不要取log1p
total_counts <- Matrix::colSums(X0)
size_factors <- total_counts / 10000
X1 <- sweep(X0, 2, size_factors, FUN = "/") #Normalization以后
### scran包来算
library(scran)
gene_means <- rowMeans(X1)
pkgdown::build_site()
pkgdown::build_site()
