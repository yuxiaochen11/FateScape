---
title: "simulation"
output: html_document
date: "2024-06-08"
---

```{r setup, include=FALSE}
library(LineageCast)
devtools::load_all("D:/Downloads/TedSim")
library(TedSim)
library(ape)
library(devtools)
library(DCLEAR)
library(phangorn)
library(TreeDist)
library(TreeTools)
library(slingshot)
library(monocle3)
```

# Generating Data
## Setting Set Simulation Parameters

```{r}
N_char <- 12         # Number of barcode characters (e.g., 8, 12, 16)
p_ds <- 0.2          # Stochastic dropout rate (e.g., 0.1, 0.2, 0.3)
mu <- 0.2            # Mutation rate (e.g., 0.1, 0.2, 0.3)
ncells <- 512        # Number of cells (e.g., 512, 1024, 2048)

# Other simulation parameters
N_nodes <- 2 * ncells - 2
ngenes <- 500
max_walk <- 8
p_a <- 0.8
n_cif <- 30
n_diff <- 20
cif_step <- 1
p_d <- 0.05         # Heritable dropout rate
r_n <- ceiling(N_char * 0.7)
# Define cell state tree in Newick format and read it as a phylogenetic tree
cell_state_tree_text <- "((((((t1:1)n9:1,(t2:1)n10:1)n8:1)n7:1,(((t3:1)n13:1)n12:1)n11:1)n6:1)n5:1)n4;"
state_lineages <- list()
state_lineages[["L1"]] <- c(4, 5, 6, 7, 8, 9, 1)
state_lineages[["L2"]] <- c(4, 5, 6, 7, 8, 10, 2)
state_lineages[["L3"]] <- c(4, 5, 6, 11, 12, 13, 3)
cell_state_tree <- read.tree(text = cell_state_tree_text)
```

## Generating Raw Lineage Barcodes and Cell States

```{r}
returnlist <- SIFGenerate(cell_state_tree, n_diff, step = cif_step)
cifs <- SimulateCIFs(ncells, cell_state_tree, p_a = p_a, n_CIF = n_cif,
                     n_diff = n_diff, step = cif_step, p_d = p_d,
                     Sigma = 0.5, mu = mu, N_char = N_char, max_walk = max_walk,
                     SIF_res = returnlist, unif_on = FALSE)

# Extract barcode data (all barcodes)
barcodes_all <- cifs[[7]]

# Extract barcode data for leaves (raw cell barcodes)
cif_leaves <- list()
for (i in 1:3) {
  cif_leaves[[i]] <- cifs[[1]][[i]][1:ncells, ]
}

# Convert CIF simulation output to true counts for RNA data
true_counts_res <- CIF2Truecounts(ngenes, ncif = n_cif, ge_prob = 0.3, ncells = ncells, 
                                  cif_res = list(cif_leaves, cifs[[2]]))
counts <- t(true_counts_res[[1]])

#save(counts,file = 'D:/projects/LineageCast/LineageCast/data/Simulation/counts.RData')
#load('D:/projects/LineageCast/LineageCast/data/Simulation/counts.RData')

# Extract cell state information from simulation results
states_leaves <- cifs[[2]][1:ncells, ]
state <- data.frame(cell_id = paste("cell", states_leaves[,"cellID"], sep = "_"),
                    cluster = as.character(states_leaves[,"cluster"]))

# Process ground truth cell division tree
tree_ct <- cifs[[4]]
for (i in 1:ncells) {
  tree_ct$tip.label[i] <- paste("cell", substr(tree_ct$tip.label[i], 2, nchar(tree_ct$tip.label[i])), sep = "_")
}
```

# Preprocessing Lineage Barcodes

```{r}
# Extract initial barcode matrix for cells
barcodes_initial <- barcodes_all[1:ncells, ]
rownames(barcodes_initial) <- paste("cell", states_leaves[, 4], sep = "_")

# Introduce stochastic dropout to simulate missing barcode data
barcodes_dropout <- stochastic_dropout(barcodes_initial, p_ds)

# Impute missing values in barcode data
barcodes <- imputation_dropout_alter(barcodes_dropout, N_char, ncells, r_n)
# Optionally: Check the number of unique barcodes
# sum(!duplicated(barcodes))
```

# Grouping Cells by State Lineage

```{r}
# Generate state lineage information using simulated cell states and imputed barcodes
sl_info <- state_lineage_info(state_lineages, ncells, state, barcodes)
state_lineage <- sl_info[[1]]
cell_lineages <- sl_info[[2]]
barcodes_lineages <- sl_info[[3]]
state_labels_lineages <- sl_info[[4]]
```

# Reconstructing Sub-Cell Division Trees

```{r}
# Record simulation start time for performance tracking
start_time <- proc.time()

# Construct initial sub-cell division trees based on state lineages and barcode data
Trees_initial <- initial_tree_construction(state_lineages, barcodes_lineages)

# Refine subtrees using maximum likelihood and subtree exchanges
LiterateRefine <- subtree_refinement(Trees_initial, state_lineages, barcodes_lineages,
                                     N_char, state_labels_lineages,
                                     lambda1 = 0.1, lambda2 = 0.9,
                                     maxIter = 100, repeat_time = 10)
bestsubtree <- LiterateRefine[[1]]

# Remove duplicated leaf nodes from the refined subtrees
bestsubtree <- drop_duplicated_tips(bestsubtree, barcodes_lineages, cell_lineages,
                                    state_lineage, alpha = 1.5, beta = 1.5)
```


# Integrating Sub-Cell Division Trees

```{r}
# Generate root barcodes for each refined subtree
subtrees_rootbar <- get_subtree_root_barcodes(bestsubtree, state, barcodes, length(state_lineages))

# Compute the common mutation matrix among subtree root barcodes
CM <- common_mutation_matrix(subtrees_rootbar)
Nodes_rank <- subtrees_rank(CM)[[1]]
Nodes_weight <- subtrees_rank(CM)[[2]]

# Decompose refined subtrees into sub-subtrees
subsubtrees <- decompose_subtrees(bestsubtree, state, barcodes, length(state_lineages))

# Merge sub-cell division trees using ordered merging
Tree_Merge <- merge_subcell_trees_ordered(CM, Nodes_rank, Nodes_weight, subsubtrees,
                                          bind_tree_list = list(), nsubtree = 1)

# Record total processing time
LineageCast_totaltime <- proc.time() - start_time

```

# Evaluating the Reconstructed Tree

```{r}
# Evaluate the merged tree against the ground truth tree
cat("Nye Similarity (higher is better): ", NyeSimilarity(tree_ct, Tree_Merge, normalize = TRUE), "\n")
cat("Tree Distance (lower is better): ", TreeDistance(tree_ct, Tree_Merge), "\n")
cat("RF Distance (lower is better): ", RF.dist(tree_ct, Tree_Merge, normalize = TRUE), "\n")
```
